## 1. 模板起源

### C语言的中的宏

- 预处理阶段进行纯文本替换
- 不会进行数据类型检查

### C 语言实现 利用宏构建通宏函数框架（宏和函数组合在一起）

- 通过实例化宏， 让预处理器将这个宏带换成针对不同数据类型的真正函数

- 将宏的通用性和函数的类型安全性结合

  ```c++
  #define MAX(T) T max_##T(T x,T y){\
  					return x>y?x:y;
  				\}
  				
  MAX(int)//由预编译器生成的函数定义
  // int max_int(int x,int y){return .....}
  
  #define Max(T) max_##T
  
  int main()
  {
  	Max(int)(10,20);
  }
  ```



## 2. 函数模板

### 定义

- 形式

  ```c++
  template<class 类型形参1, class 类型形参2,...>
  返回值类型 函数模板名（调用形参1, 调用形参2,...）
  {
  ...
  }
  ```

### 使用

- 必须先实例化
- 函数模板名<类型**实参**1，类型**实参**2, ...>(调用**实参**1，调用**实参**2，...);

### 分析(本质)

- **编译器**在看到实例化后(使用函数模板), 会根据类型实参从函数模板中产生一个真正的函数实体

### 实例化的条件

- 原则上来说可以使用任何类型来实例化函数模板，不管其为基本类型还是类类型。

- 前提是这个类型必须支持函数模板所要执行的操作。
  
  例如：一个不支持 “>” 操作符的类型来实例化 Max 函数模板，编译器将报错误。

### 拓展

- **二次编译**
  - 编译器对函数模板都会进行两次编译。
  - 第一次编译发生在实例化函数模板之前（产生真正函数实体之前）只检查函数模板本身内部代码，查看基本语法是否正确。　  
    - 函数模板内部出现的所有标识符是否均有声明
    - 对于已知类型 class 的调用 method 要查看调用是否有效
    - 对于未知类型调用认为都合理， 除了`<>`
  - 第二次编译发生在实例化函数模板之后（产生真正函数实体之后）结合所使用的类型实参，再次检查模板代码，查看所有调用是否真的均有效。

- **隐式推断类型实参**

  - 如果函数模板的调用形参和类型形参相关(一样)。
　　例如：`template<class T> T Max(T x, T y){...}`

  - 那么在实例化函数模板时即使不显示指明函数模板的类型实参，编译器也有能力
　　根据调用实参的类型隐式推断出正确的类型实参的类型。
　　例如：`Max(123,456); ⇒ Max<int>(123,456);`

  - 获得和调用普通函数一致的语法表现形式。

  **以下3种不支持隐式推断**

  - 调用参数 和 类型参数 不完全相关
    例如：`template<class T,class D> T Max(T x,T y){}`

  - 隐式推断不支持隐式类型转换
    例如：`template<class T> T Max(T x, T y){...}`
　　使用时：`Max(123,45.6);`

  - 返回值类型不支持隐式推断。

- 重载

  - 普通函数和可实例化出该函数的函数模板构成重载关系
    在数据类型匹配度相同的情况下，编译器优先选择普通函数
  - 函数模板的实例化不支持隐式转换，如果传递参数是需要编译器做隐式转换，则编译器选择普通函数
  - 在实例化时，可以用<> 强行使用函数模板

## 3. 类模板

### 类模板声明

``` c++
template <class 类型形参1 ...> class 类模板名 {...}
```

类模板可以声明在头文件，实现放在`.inl`文件

``` c++
tamplate <class T> T Cmath<T>::add(){}
```

### 类模板使用

- 使用类模板必须对类模板进行实例化（产生真正的类）类模板本身并不代表一个确定的类型（即不能用于定义对象），只有通过类型实参实例化成真正的类后才具备类的语义(即可以定义对象)。
  
  例如：`CMath<int,double> math;`

- 类模板被实例化时类模板中的成员函数并没有实例化，成员函数只有在被调用时才会被实例化（即产生真正成员函数）
  > NOTE：成员虚函数除外
- 某些类型虽然后没有提供类模板所需要的全部功能但照样可以实例化类模板，只要不调用那些未提供功能的成员函数即可。

### 类模板的静态成员

- 类模板中的静态成员即不是每个对象拥有一份
- 也不是类模板拥有一份。
- 而应该是由类模板实例化出的每一个真正的类各有一份。
- 且为该实例化类定义的所有对象共享。

### 类模板的递归实例化

- 可以使用任何类型来实例化模板
- 由类模板实例化产生的类也可以用来实例化类模板自身， 叫做类模板的递归实例化
- 通过这种方法可以构建空间上具有递归特征的数据结构 （比如：多维数组）`vector<vector<int>>`



## 4. 类模板扩展

### 全局特化

- 全类特化：特化类模板的所有成员函数, 相当于重写了一个针对某种特定数据类型的具体类

  ```c++
  template<> 
  class Cmath<float>
  {
  ...
  }
  
  ```

- 成员特化: 如果只有某个成员不行就特化整个模板，代价太大，所有有了成员特化

  ```c++
  template<>
  char* const CMath<char* const>::add(){...}
  ```



### 局部特化

只特化一部分类型参数

```C++
template< class T, class D> 
class Cmath{...};

// 局部特化
template<class T> 
class Cmath<T,float>{...};

// 也是局部特化，要求两个类型一致
template<class T> 
class Cmath<T,T>{...};

// 也是局部特化
template<class T, class D> 
class Cmath<T*, D*>{...};
```

- 除非必要，否则尽量不要特化，因为特化版本过多容易引发编译器匹配歧义

  

### 类型形参的缺省

- 类模板的**类型形参**可以带缺省值， 实例化时，如果提供了**类型实参**，则用所提供的类型实参来实例化。如果没有提供类型实参，则用相应的**类型形参的缺省类型**来实例化类模板

   ```c++
   template< class T = int, class D = float> //设置了类型形参的缺省类型
   class Cmath{...};

   Cmath <int, float> m1;
   Cmath <> m2;

   ```

### 数值形（整形）的模板参数()

- 类模板的模板形参并不限于类型参数，普通数值也可以作为模板的参数

   ```c++
   template <class T, size_t S=15> 
   class Array
   {
   	T m_array[S];
       size_t size(){return S;};
   } 
   
   Array<int,10> a;
   ```

### 模板技巧

- 模板型成员变量 ：成员变量， 但是类型是由一个类模板实例化的未知类

  ```c++
  template<class T> 
  class Array{..};
  
  template<class D>
  class Sum
  {
  	Array<D> m_s;//模板类型成员变量
  } 
  ```

- 模板型成员函数：类模板的成员函数模板

  ```c++
  template<class T>
  class Cmath
  {
  public:
      template<class D> void foo(){...}
  }
  
  // 如果在类外实现
  
  template<class T>
      template <class D>
  	void Cmath<T>::foo(){...};
  ```

- 模板型成员类型： 类模板中嵌套的类模板

  ```c++
  template<class X>
  class A{
  public:
  	template<class Y> 
      class B{
      ...
      };
  };
  
  ```

- 模板型模板参数 ： 模板的模板形参 也可以是类模板，可以有缺省值

## 5. 典型错误

### 嵌套依赖

```c++
class A
{
public:
    class B
    {
    public:
        void foo(){}
    };
};

template<class T> 
void Func()
{
    T::B b;// 嵌套依赖， 编译器会把 T::B 理解成是 B 是 T 的静态成员变量
    typename T::B b; //改正
    b.foo()
}
```

- 问题: 

  由于模板要经历两次编译，在**第一次编译**代码时，类型形参的具体类型尚不明确，编译器将把类型形参（T）的嵌套类型（B）**理解为某个未知类型的静态成员变量**（T::B），因此编译器看到使用这样的标识符声明变量时会报告错误

- 解决：

  在类型形参的前面增加一个typename标识符，告诉编译器其后是一个类模板的嵌套使用

### 依赖 模板参数 访问 成员函数模板

```c++
class A
{
public:
  template<class T> 
  void foo(){}
};

template<class D>
void Func()
{
  D d;
  d.foo()<float>();// 错误
  d.template foo<int>();// 改正
}
```

- 问题： 利用未知类定义的对象来访问成员函数模板时，编译器在**第一次编译时**，**无法解析成员函数模板**的类型参数列表的 `<>` 而报告编译错误。 **编译器第一次编译时无法理解 <>**
- 解决：在成员函数模板之前增加template关键字，告诉编译器其后是一个函数的模板实例，编译器就可以正确理解<>

### 子模板访问基模板

只有类才有继承，类模板没有继承

```c++
template<class T>
class Base
{
public:
  int i; 
  void foo(){}
};

template <class T, class D> 
class Derived : public Base<T>// 继承自未知类
{
 public:
  void bar(){i=100;foo();}  //错误
  void bar(){Base<T>::i=100; Base<T>::foo();}  //改正方法 1: Base<T>未知类，未知类型调用->编译器会隐忍
  void bar(){this->i=100; this->foo();}  //改正方法 2: this 为子类，也是未知类，未知类型调用->编译器会隐忍
    
}
```

- 问题：

  在子类模板中访问基类模板的成员，编译器**第一次编译**时只会在**子类模板和全局中**搜索使用的标识符符号，不会到基类模板中搜索

- 解决：

  在子类模板中可以通过使用**作用域限定符**或显示使用**this指针**

### 零值初始化

**编译器不会报错，就是基本类型会出现问题**

- 问题：

  - 基本类型(int, float, etc. )不存在缺省构造函数，未被初始化的局部变量都有一个**不确定的值**

  - 类类型由于存在缺省构造函数(Default constructor)，未被初始化的情况下可以有一个**确定的缺省初始化状态**

  基于上述两点，就会在模板实现中产生不一致的语法语义

- 解决：

  如果希望模板中，所有类型参数的变量，无论是类类型还是基本类型都以缺省方式获得初始化，就必须对其进项**显式的缺省构造T()**
  ```c++
  template <class T> void Function()
  {
    T t = T(); //显式的缺省构造T()
    .....
  }
  ```

### 类模板中的成员虚函数

- 类模板中的`普通成员函数`可以是虚函数

  即可以为类定义成员虚函数，和普通类的成员虚函数一样，**类模板的成员虚函数也可以表现出多态性**

- 类模板中的 `成员函数模板` 不可以是虚函数
  ``` c++
  template<class T>
  class Base {
  public:
    virtual void foo(){
        cout << "Base<T>::foo()" << endl;
    }
  };

  template<class T, class D>
  class Derived : public Base<T> {
  public:
  /*
    void foo(){
        cout << "Derived<T,D>::foo()" << endl;
    }
  */
    virtual template<class M>
    void bar(){
        
    }
  };
  ```

  根据成员虚函数的多态机制，需要一个虚函数表，而这个**虚函数表是编译器在实例化类模板是就生成**，

  而类的成员函数模板的实例化需要编译器处理完调用后才会生成，这是才出现成员虚函数的地址

  在实例化`Derived<int,int> a` 的时候，compiler就会产生子类，就需要把虚函数地址存在虚函数表。但是`bar()`实例化是在函数被调用的时候在会

- 成员函数模板的延迟编译阻碍了虚函数表的静态构建 

















